<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8">
  <title>Orbital Inclination Demo</title>
  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script>
    // ——— Sahne, Kamera, Renderer ———
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(3,3,3);
    camera.lookAt(0,0,0);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    // ——— Sabitler ———
    const sma = 1, ecc = 0.5;
    const inc = THREE.MathUtils.degToRad(45);
    const w   = THREE.MathUtils.degToRad(90);
    const Om  = THREE.MathUtils.degToRad(90);

    // ——— Yörünge Noktalarını Hesapla ———
    const pts = [];
    for(let deg=0; deg<=360; deg++){
      const f = THREE.MathUtils.degToRad(deg);
      const r = sma*(1-ecc*ecc)/(1+ecc*Math.cos(f));
      // Kepler 3D dönüşümü: Rz(Om)·Rx(inc)·Rz(w)
      const cw = Math.cos(w), sw = Math.sin(w),
            ci = Math.cos(inc), si = Math.sin(inc),
            cO = Math.cos(Om), sO = Math.sin(Om);
      // başlangıç (x,y,0)
      let x = r*Math.cos(f), y = r*Math.sin(f), z = 0;
      // 1) Rz(w)
      [x,y] = [ x*cw - y*sw, x*sw + y*cw ];
      // 2) Rx(inc)
      [y,z] = [ y*ci - z*si, y*si + z*ci ];
      // 3) Rz(Om)
      [x,y] = [ x*cO - y*sO, x*sO + y*cO ];
      pts.push(new THREE.Vector3(x,y,z));
    }
    const orbitGeo = new THREE.BufferGeometry().setFromPoints(pts);
    const orbitMat = new THREE.LineBasicMaterial({color:0x000000, linewidth:2});
    const orbit   = new THREE.LineLoop(orbitGeo, orbitMat);
    scene.add(orbit);

    // ——— Sky-plane Mesh ———
    const size = 2.4, seg = 10;
    const planeGeo = new THREE.PlaneGeometry(size, size, seg, seg);
    const planeMat = new THREE.MeshBasicMaterial({
      color:0x008080, transparent:true, opacity:0.1, side:THREE.DoubleSide
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    scene.add(plane);

    // ——— Axis Arrows ve Etiketler ———
    const arrowDirs = {
      'Kuzey': [1.1,0,0],
      'Doğu':  [0,1.1,0],
      'Bakış': [0,0,1.1]
    };
    Object.entries(arrowDirs).forEach(([lbl,vec])=>{
      const dir = new THREE.Vector3(...vec).normalize();
      const arr = new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), 1.1, 0x555555, 0.07, 0.05);
      scene.add(arr);
      // 2D etiket: basit bir sprite
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#555';
      ctx.font = '24px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(lbl, 64, 64);
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      sprite.position.set(...vec.map(v=>v*0.95));
      sprite.scale.set(0.6,0.6,0.6);
      scene.add(sprite);
    });

    // ——— Node Line ———
    // axis = k×n
    const k = new THREE.Vector3(0,0,1);
    const n = new THREE.Vector3(
      Math.sin(inc)*Math.sin(Om),
      -Math.sin(inc)*Math.cos(Om),
      Math.cos(inc)
    );
    const axis = new THREE.Vector3().crossVectors(k,n).normalize();
    const pts2 = [axis.clone().multiplyScalar(-1.2), axis.clone().multiplyScalar(1.2)];
    const nodeGeo = new THREE.BufferGeometry().setFromPoints(pts2);
    const nodeMat = new THREE.LineDashedMaterial({color:0x888888, dashSize:0.1, gapSize:0.1, linewidth:1});
    const nodeLine = new THREE.Line(nodeGeo, nodeMat);
    nodeLine.computeLineDistances();
    scene.add(nodeLine);

    // ——— Asc/Des Node Marker ———
    const fAsc = (2*Math.PI - w)%(2*Math.PI);
    const fDes = (fAsc + Math.PI)%(2*Math.PI);
    function pointAt(f){
      const r = sma*(1-ecc*ecc)/(1+ecc*Math.cos(f));
      let x=r*Math.cos(f), y=r*Math.sin(f), z=0;
      // Rz(w)
      [x,y] = [ x*Math.cos(w)-y*Math.sin(w), x*Math.sin(w)+y*Math.cos(w) ];
      // Rx(inc)
      [y,z] = [ y*Math.cos(inc)-z*Math.sin(inc), y*Math.sin(inc)+z*Math.cos(inc) ];
      // Rz(Om)
      [x,y] = [ x*Math.cos(Om)-y*Math.sin(Om), x*Math.sin(Om)+y*Math.cos(Om) ];
      return new THREE.Vector3(x,y,z);
    }
    const asc = pointAt(fAsc), des = pointAt(fDes);
    const mkMatAsc = new THREE.MeshBasicMaterial({color:0x1e90ff});
    const mkMatDes = new THREE.MeshBasicMaterial({color:0xb22222});
    const sphGeo   = new THREE.SphereGeometry(0.04,8,8);
    const ascMp = new THREE.Mesh(sphGeo, mkMatAsc);
    const desMp = new THREE.Mesh(sphGeo, mkMatDes);
    ascMp.position.copy(asc); desMp.position.copy(des);
    scene.add(ascMp, desMp);

    // ——— Periastron Marker ———
    const peri = pointAt(0);
    const periMp = new THREE.Mesh(
      new THREE.SphereGeometry(0.05, 12,12),
      new THREE.MeshBasicMaterial({color:'gold'})
    );
    periMp.position.copy(peri);
    scene.add(periMp);

    // ——— Inclination Wedge ———
    // rodres = Rodrigues(e1 × axis_norm)
    const e1 = new THREE.Vector3().crossVectors(axis,k).normalize();
    const wedgePts = [];
    for(let t=0; t<=40; t++){
      const th = inc * t/40;
      // Rodrigues
      const v = e1.clone().multiplyScalar(Math.cos(th))
        .add(new THREE.Vector3().crossVectors(axis,e1).multiplyScalar(Math.sin(th)))
        .add(axis.clone().multiplyScalar(axis.dot(e1)*(1-Math.cos(th))));
      wedgePts.push(v);
    }
    // üçgen mesh
    const wedgeGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), ...wedgePts, wedgePts[0]]);
    wedgeGeo.setIndex([...Array(wedgePts.length+1).keys()].flatMap((i,i0,arr)=>(i0>0?[[0,i0, i0+1]]:[])));
    const wedgeMat = new THREE.MeshBasicMaterial({color:'purple', side:THREE.DoubleSide, transparent:true, opacity:0.4});
    const wedgeMesh= new THREE.Mesh(wedgeGeo, wedgeMat);
    scene.add(wedgeMesh);

    // ——— Barycenter (Focus) ———
    const star = new THREE.Mesh(
      new THREE.SphereGeometry(0.07,16,16),
      new THREE.MeshBasicMaterial({color:'black'})
    );
    scene.add(star);

    // ——— Label “i” ———
    const canvas2 = document.createElement('canvas');
    canvas2.width = canvas2.height = 128;
    const ctx2 = canvas2.getContext('2d');
    ctx2.fillStyle = 'purple';
    ctx2.font = '28px serif';
    ctx2.textAlign = 'center';
    ctx2.fillText('i', 64, 64);
    const tex2 = new THREE.CanvasTexture(canvas2);
    const spr2 = new THREE.Sprite(new THREE.SpriteMaterial({map:tex2}));
    // orta nokta:
    const mid = wedgePts[Math.floor(wedgePts.length/2)];
    spr2.position.copy(mid);
    spr2.scale.set(0.3,0.3,0.3);
    scene.add(spr2);

    // ——— Render Döngüsü ———
    function animate(){
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();

    // ——— Pencere Yeniden Boyut ———
    window.addEventListener('resize',()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
