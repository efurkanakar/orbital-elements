<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Orbital Orientation — i, Ω, ω</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; }
    body {
      margin: 0;
      height: 100vh;               /* full screen */
      overflow: hidden;            /* no page scroll */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:#000;             /* pure black */
      color:#e9eefc;
    }
    header{ padding:12px 16px; border-bottom:1px solid #1b2344; background:#000; }
    h1{ margin:0; font-size:18px; letter-spacing:.2px }

    main {
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:14px;
      height: calc(100vh - 46px);  /* header height compensation */
      padding:12px;
      box-sizing: border-box;
    }

    /* Scene containers */
    #sceneWrap{
      position:relative; border:1px solid #1b2344; border-radius:12px; overflow:hidden; background:#000; display:flex; min-height:0;
    }
    #scene{ flex:1; height:100%; }

    #overlay{ position:absolute; left:10px; top:10px; font-size:13px; color:#d2dcff; background:rgba(20,20,30,.55); padding:8px 10px; border-radius:8px; border:1px solid #1b2344 }

    .panel { border:1px solid #1b2344; border-radius:12px; padding:12px; background:#0f1530; height: 100%; box-sizing:border-box; display:flex; flex-direction:column; gap:12px; }

    .slider { }
    .slider label { display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:14px; margin-bottom:6px; color:#e9eefc }
    .slider input[type=range]{ width:100%; }
    .value{ font-variant-numeric: tabular-nums; color:#a6c1ff }

    .chip{ display:inline-block; padding:2px 6px; border-radius:999px; border:1px solid #1b2344; margin-right:6px }
    .chip.teal{ background:#0a2a2a; color:#9bf2f2 }
    .chip.green{ background:#0a2f1f; color:#9ff2bf }
    .chip.orange{ background:#3a2406; color:#ffd29b }

    canvas{ display:block; }

    @media (max-width:980px){
      main{ grid-template-columns: 1fr; }
      .panel{ height:auto; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Orbital Orientation — i, Ω, ω</h1>
  </header>

  <main>
    <div id="sceneWrap">
      <div id="overlay">
        <div><span class="chip teal">Sky plane</span> <span class="chip green">Ω arc</span> <span class="chip orange">ω arc</span></div>
        <div>▲: Ascending node &nbsp; ▽: Descending node &nbsp; ◆: Periastron</div>
      </div>
      <div id="scene"></div>
    </div>

    <aside class="panel">
      <div class="slider">
        <label for="iRange">Inclination i (°) <span class="value" id="iVal"></span></label>
        <input id="iRange" type="range" min="0" max="180" step="1" value="45">
      </div>
      <div class="slider">
        <label for="OmRange">Longitude of nodes Ω (°) <span class="value" id="OmVal"></span></label>
        <input id="OmRange" type="range" min="0" max="360" step="1" value="90">
      </div>
      <div class="slider">
        <label for="wRange">Argument of periastron ω (°) <span class="value" id="wVal"></span></label>
        <input id="wRange" type="range" min="0" max="360" step="1" value="90">
      </div>
    </aside>
  </main>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ====== Parameters ======
    const a = 1.0;       // semi-major axis (arb. units)
    const e = 0.5;       // eccentricity
    const N = 512;       // ellipse sampling
    const fLine = Array.from({length:N}, (_,k)=> k*(2*Math.PI/(N-1)));

    // HTML refs
    const wrap = document.getElementById('sceneWrap');
    const host = document.getElementById('scene');
    const iRange  = document.getElementById('iRange');
    const OmRange = document.getElementById('OmRange');
    const wRange  = document.getElementById('wRange');
    const iVal  = document.getElementById('iVal');
    const OmVal = document.getElementById('OmVal');
    const wVal  = document.getElementById('wVal');
    const setLabels=()=>{ iVal.textContent=iRange.value+'°'; OmVal.textContent=OmRange.value+'°'; wVal.textContent=wRange.value+'°'; };
    setLabels();

    // ====== Scene ======
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(50, 16/9, 0.01, 100);
    camera.position.set(3.5, 3.2, 2.6);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    host.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x222233, .9);
    scene.add(hemi);

    // ====== Sky plane (z=0) ======
    const skyMat = new THREE.MeshBasicMaterial({ color: 0x1fb4b4, transparent:true, opacity:0.12, side:THREE.DoubleSide });
    const skyGeom = new THREE.PlaneGeometry(3.2, 3.2, 1, 1);
    const sky = new THREE.Mesh(skyGeom, skyMat);
    scene.add(sky);

    // ====== Axis arrows ======
    const axisLen = 1.4;
    const arrows = [];
    const makeArrow=(dir, col)=>{
      const ar = new THREE.ArrowHelper(dir.clone().normalize(), new THREE.Vector3(0,0,0), axisLen, col, 0.08, 0.04);
      scene.add(ar); arrows.push(ar);
      return ar;
    };
    const north = makeArrow(new THREE.Vector3( 1,0,0), 0xaaaaaa); // +X
    const south = makeArrow(new THREE.Vector3(-1,0,0), 0x666666); // -X
    const los   = makeArrow(new THREE.Vector3( 0,0,1), 0xaaaaaa); // +Z

    // ====== Text labels as sprites ======
    function makeLabel(text){
      const c = document.createElement('canvas');
      const ctx = c.getContext('2d');
      const fs = 48; const pad=12; const fw = '500';
      ctx.font = `${fw} ${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      const w = Math.ceil(ctx.measureText(text).width) + pad*2;
      const h = fs + pad*2;
      c.width = w; c.height = h;
      ctx.font = `${fw} ${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.fillStyle = 'rgba(255,255,255,0.95)';
      ctx.textBaseline = 'middle'; ctx.textAlign='center';
      ctx.fillText(text, w/2, h/2);
      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter; tex.generateMipmaps = false;
      const mat = new THREE.SpriteMaterial({ map: tex, transparent:true });
      const sp = new THREE.Sprite(mat);
      const scale = 0.5; sp.scale.set((w/h)*scale, 1*scale, 1);
      return sp;
    }
    const labelNorth = makeLabel('North');
    const labelSouth = makeLabel('South');
    const labelLoS   = makeLabel('Line of Sight');
    scene.add(labelNorth, labelSouth, labelLoS);

    // ====== Helpers ======
    const Rz = (t)=>{ const c=Math.cos(t), s=Math.sin(t); return new THREE.Matrix3().set( c,-s,0,  s, c,0,  0,0,1 ); };
    const Rx = (t)=>{ const c=Math.cos(t), s=Math.sin(t); return new THREE.Matrix3().set( 1,0,0,  0, c,-s,  0, s, c ); };
    const applyM3 = (m, v)=>{ const e=m.elements; const x=v.x, y=v.y, z=v.z; return new THREE.Vector3( e[0]*x + e[1]*y + e[2]*z, e[3]*x + e[4]*y + e[5]*z, e[6]*x + e[7]*y + e[8]*z ); };
    const kepler3d=(a,e,inc,w,Om,f)=>{ const r = a*(1-e*e)/(1+ e*Math.cos(f)); const x = r*Math.cos(f), y=r*Math.sin(f), z=0; const M = new THREE.Matrix3(); const m = new THREE.Matrix3(); M.copy(Rz(Om)); m.copy(Rx(inc)); M.multiply(m); m.copy(Rz(w)); M.multiply(m); return applyM3(M, new THREE.Vector3(x,y,z)); };
    const rodrigues=(v,k,th)=>{ const vc=v.clone(); const kc=k.clone(); const c=Math.cos(th), s=Math.sin(th); const cross = new THREE.Vector3().copy(kc).cross(vc).multiplyScalar(s); const dot = kc.dot(vc); return vc.multiplyScalar(c).add(cross).add(kc.multiplyScalar(dot*(1-c))); };

    // ====== Geometries ======
    const orbitMat = new THREE.LineBasicMaterial({ color:0xffffff, linewidth:1 });
    const orbitGeom = new THREE.BufferGeometry();
    const orbit = new THREE.Line(orbitGeom, orbitMat);
    scene.add(orbit);

    const nodeMat = new THREE.LineDashedMaterial({ color:0xaaaaaa, dashSize:0.08, gapSize:0.05 });
    const nodeGeom = new THREE.BufferGeometry();
    const nodeLine = new THREE.Line(nodeGeom, nodeMat);
    scene.add(nodeLine);

    const asc = new THREE.Mesh(new THREE.SphereGeometry(0.04, 16, 16), new THREE.MeshBasicMaterial({color:0x3fa9ff}));
    const des = new THREE.Mesh(new THREE.SphereGeometry(0.04, 16, 16), new THREE.MeshBasicMaterial({color:0xd24b4b}));
    scene.add(asc, des);

    const peri = new THREE.Mesh(new THREE.OctahedronGeometry(0.045, 0), new THREE.MeshBasicMaterial({color:0xffe073}));
    scene.add(peri);

    const OmMat = new THREE.LineBasicMaterial({ color:0x2bb36c });
    const OmGeom = new THREE.BufferGeometry();
    const OmArc = new THREE.Line(OmGeom, OmMat);
    scene.add(OmArc);

    const wMat = new THREE.LineBasicMaterial({ color:0xffa142 });
    const wGeom = new THREE.BufferGeometry();
    const wArc = new THREE.Line(wGeom, wMat);
    scene.add(wArc);

    const wedgeMat = new THREE.MeshBasicMaterial({ color:0x9b59ff, opacity:0.35, transparent:true, side:THREE.DoubleSide });
    let wedgeMesh = new THREE.Mesh(new THREE.BufferGeometry(), wedgeMat);
    scene.add(wedgeMesh);

    // ====== Update ======
    const kvec = new THREE.Vector3(0,0,1);

    function update(){
      setLabels();
      const inc = THREE.MathUtils.degToRad(parseFloat(iRange.value));
      const w   = THREE.MathUtils.degToRad(parseFloat(wRange.value));
      const Om  = THREE.MathUtils.degToRad(parseFloat(OmRange.value));

      // Orbit
      const pts = new Float32Array(3*N);
      for(let i=0;i<N;i++){
        const f = fLine[i];
        const p = kepler3d(a,e,inc,w,Om,f);
        pts[3*i]=p.x; pts[3*i+1]=p.y; pts[3*i+2]=p.z;
      }
      orbitGeom.setAttribute('position', new THREE.BufferAttribute(pts,3));
      orbitGeom.computeBoundingSphere();

      // Periastron (f=0)
      peri.position.copy(kepler3d(a,e,inc,w,Om,0));

      // Node direction: n = (sin i sin Ω, -sin i cos Ω, cos i)
      const n = new THREE.Vector3(
        Math.sin(inc)*Math.sin(Om),
        -Math.sin(inc)*Math.cos(Om),
        Math.cos(inc)
      );
      const axis = new THREE.Vector3().copy(kvec).cross(n);
      const sin_i = axis.length();
      let lhat = new THREE.Vector3(1,0,0);
      if (sin_i>1e-8){ lhat.copy(axis).multiplyScalar(1/sin_i); }

      // Node line
      const L = 1.6;
      const nd = new Float32Array([
        -L*lhat.x, -L*lhat.y, -L*lhat.z,
         L*lhat.x,  L*lhat.y,  L*lhat.z
      ]);
      nodeGeom.setAttribute('position', new THREE.BufferAttribute(nd,3));
      nodeGeom.computeBoundingSphere();
      nodeLine.computeLineDistances();

      // Asc/Desc nodes (f_asc = 2π - ω)
      const f_asc = (2*Math.PI - (w%(2*Math.PI)))%(2*Math.PI);
      const Pa = kepler3d(a,e,inc,w,Om,f_asc);
      const Pd = kepler3d(a,e,inc,w,Om,(f_asc+Math.PI)%(2*Math.PI));
      asc.position.copy(Pa);
      des.position.copy(Pd);

      // Ω arc in z=0
      const rasc = Math.hypot(Pa.x, Pa.y);
      const M = 120; const omPts = new Float32Array(3*M);
      for(let k=0;k<M;k++){
        const t = (k/(M-1))*Om; // 0→Ω
        omPts[3*k]  = rasc*Math.cos(t);
        omPts[3*k+1]= rasc*Math.sin(t);
        omPts[3*k+2]= 0;
      }
      OmGeom.setAttribute('position', new THREE.BufferAttribute(omPts,3));

      // ω arc on orbit
      const W = 180; const wPts = new Float32Array(3*W);
      for(let k=0;k<W;k++){
        const t = (k/(W-1))*w; const f = (f_asc + t)%(2*Math.PI);
        const Q = kepler3d(a,e,inc,w,Om,f);
        wPts[3*k]=Q.x; wPts[3*k+1]=Q.y; wPts[3*k+2]=Q.z;
      }
      wGeom.setAttribute('position', new THREE.BufferAttribute(wPts,3));

      // i wedge (tri fan via Rodrigues)
      const e1 = new THREE.Vector3().copy(lhat).cross(kvec);
      if (sin_i<1e-8 || e1.length()<1e-8){
        wedgeMesh.geometry.dispose(); wedgeMesh.geometry = new THREE.BufferGeometry();
      } else {
        e1.normalize();
        const radius = 1.05; const S = 64;
        const verts = [];
        const center = new THREE.Vector3(0,0,0);
        let prev = null;
        for(let s=0;s<=S;s++){
          const th = (s/S)*inc;
          const p = rodrigues(e1.clone().multiplyScalar(radius), lhat, th);
          if(prev){ verts.push(center.x,center.y,center.z, prev.x,prev.y,prev.z, p.x,p.y,p.z); }
          prev = p;
        }
        const arr = new Float32Array(verts);
        const g = new THREE.BufferGeometry();
        g.setAttribute('position', new THREE.BufferAttribute(arr,3));
        wedgeMesh.geometry.dispose(); wedgeMesh.geometry = g;
      }

      // Position labels near arrows
      const off = 0.14;
      labelNorth.position.set( north.position.x + axisLen, north.position.y, north.position.z );
      labelSouth.position.set(-axisLen, 0, 0);
      labelLoS.position.set( 0, 0, axisLen + 0.05 );
    }

    // Simple orbit camera controls
    let isDown=false, lx=0, ly=0, theta=0.8, phi=0.9, R=4.3;
    function updateCam(){
      const x = R*Math.sin(theta)*Math.cos(phi);
      const y = R*Math.sin(theta)*Math.sin(phi);
      const z = R*Math.cos(theta);
      camera.position.set(x,y,z);
      camera.lookAt(0,0,0);
    }
    updateCam();

    host.addEventListener('mousedown', (e)=>{ isDown=true; lx=e.clientX; ly=e.clientY; });
    window.addEventListener('mouseup', ()=>{ isDown=false; });
    window.addEventListener('mousemove', (e)=>{
      if(!isDown) return;
      const dx=(e.clientX-lx)/200, dy=(e.clientY-ly)/200; lx=e.clientX; ly=e.clientY;
      phi -= dx; theta = THREE.MathUtils.clamp(theta - dy, 0.001, Math.PI-0.001);
      updateCam();
    });
    // Prevent page scroll on wheel, use for zoom
    host.addEventListener('wheel', (e)=>{ e.preventDefault(); R = THREE.MathUtils.clamp(R + (e.deltaY>0?0.2:-0.2), 2.2, 10); updateCam(); }, {passive:false});

    // Slider events
    for (const el of [iRange, OmRange, wRange]) el.addEventListener('input', update);

    // Resize
    function resize(){
      const r = wrap.getBoundingClientRect();
      const h = r.height;
      renderer.setSize(r.width, h);
      camera.aspect = r.width / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', ()=>{ resize(); });

    // Initial
    resize();
    update();

    // Render loop
    function loop(){
      renderer.render(scene,camera);
      requestAnimationFrame(loop);
    }
    loop();
  </script>
</body>
</html>
